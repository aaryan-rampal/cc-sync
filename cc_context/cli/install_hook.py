#!/usr/bin/env python3
"""
cc-install-hook: Install git hooks for automatic context capture

This command installs two git hooks:
1. post-commit: Automatically captures Claude Code context after each commit
2. post-checkout: Notifies when context is available after checking out a commit
"""

import sys
import subprocess
import argparse
from pathlib import Path


def install_hook(force: bool = False):
    """Install git hooks to current repository"""
    try:
        from cc_context.utils.path import get_repo_root

        repo_root = get_repo_root()
        hooks_dir = repo_root / ".git" / "hooks"

        # Ensure hooks directory exists
        hooks_dir.mkdir(parents=True, exist_ok=True)

        # Install post-commit hook (runs AFTER commit is created)
        post_commit_hook = hooks_dir / "post-commit"
        post_commit_content = """#!/bin/bash
# Claude Code Context Manager - Auto-capture context after commit
# Generated by cc-install-hook

echo "üì∏ Capturing Claude Code context..."
cc-capture

# Don't fail if capture fails (commit already created)
exit 0
"""

        # Install post-checkout hook
        post_checkout_hook = hooks_dir / "post-checkout"
        post_checkout_content = """#!/bin/bash
# Claude Code Context Manager - Notify about available context
# Generated by cc-install-hook

# Get the new commit SHA (3rd argument is flag: 1 for branch checkout, 0 for file checkout)
CHECKOUT_TYPE=$3

# Only check for context on branch checkouts
if [ "$CHECKOUT_TYPE" = "1" ]; then
    NEW_COMMIT=$(git rev-parse HEAD)
    SNAPSHOT_DIR=".cc-snapshots/$NEW_COMMIT"

    if [ -d "$SNAPSHOT_DIR" ]; then
        echo ""
        echo "üí¨ Claude Code context available for this commit!"
        echo "   Run: cc-restore"
        echo ""
    fi
fi

exit 0
"""

        # Check if post-commit hook already exists
        if post_commit_hook.exists():
            if force:
                # Force flag: overwrite without asking
                backup_path = post_commit_hook.with_suffix(".backup")
                post_commit_hook.rename(backup_path)
                print(f"‚úì  Backed up existing hook to: {backup_path}")
                post_commit_hook.write_text(post_commit_content)
                post_commit_hook.chmod(0o755)
                print(f"‚úì  Installed post-commit hook")
            else:
                print(f"‚ö†Ô∏è  Post-commit hook already exists at: {post_commit_hook}")
                try:
                    response = input("   Overwrite existing post-commit hook? [y/N] ").strip().lower()
                    if response == 'y':
                        # Backup existing hook
                        backup_path = post_commit_hook.with_suffix(".backup")
                        post_commit_hook.rename(backup_path)
                        print(f"   Backed up existing hook to: {backup_path}")
                        post_commit_hook.write_text(post_commit_content)
                        post_commit_hook.chmod(0o755)
                        print(f"‚úì  Installed post-commit hook")
                    else:
                        print("   Skipped post-commit hook installation")
                except EOFError:
                    print("\n   Skipped post-commit hook installation (use --force to overwrite)")
        else:
            post_commit_hook.write_text(post_commit_content)
            post_commit_hook.chmod(0o755)
            print(f"‚úì  Installed post-commit hook at: {post_commit_hook}")

        # Check if post-checkout hook already exists
        if post_checkout_hook.exists():
            if force:
                # Force flag: overwrite without asking
                backup_path = post_checkout_hook.with_suffix(".backup")
                post_checkout_hook.rename(backup_path)
                print(f"‚úì  Backed up existing hook to: {backup_path}")
                post_checkout_hook.write_text(post_checkout_content)
                post_checkout_hook.chmod(0o755)
                print(f"‚úì  Installed post-checkout hook")
            else:
                print(f"‚ö†Ô∏è  Post-checkout hook already exists at: {post_checkout_hook}")
                try:
                    response = input("   Overwrite existing post-checkout hook? [y/N] ").strip().lower()
                    if response == 'y':
                        # Backup existing hook
                        backup_path = post_checkout_hook.with_suffix(".backup")
                        post_checkout_hook.rename(backup_path)
                        print(f"   Backed up existing hook to: {backup_path}")
                        post_checkout_hook.write_text(post_checkout_content)
                        post_checkout_hook.chmod(0o755)
                        print(f"‚úì  Installed post-checkout hook")
                    else:
                        print("   Skipped post-checkout hook installation")
                except EOFError:
                    print("\n   Skipped post-checkout hook installation (use --force to overwrite)")
        else:
            post_checkout_hook.write_text(post_checkout_content)
            post_checkout_hook.chmod(0o755)
            print(f"‚úì  Installed post-checkout hook at: {post_checkout_hook}")

        print()
        print("=" * 60)
        print("üéâ Git hooks installed successfully!")
        print("=" * 60)
        print()
        print("The hooks will now automatically:")
        print("  ‚Ä¢ Capture Claude Code context after every commit")
        print("  ‚Ä¢ Notify when context is available after checkout")
        print()
        print("To test the setup:")
        print("  1. Make some changes")
        print("  2. git add .")
        print("  3. git commit -m 'Test context capture'")
        print()
        print("To uninstall hooks, delete:")
        print(f"  - {post_commit_hook}")
        print(f"  - {post_checkout_hook}")
        print()

        return 0

    except subprocess.CalledProcessError:
        print("‚ùå Error: Not in a git repository", file=sys.stderr)
        print("   Run this command from inside a git repository", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"‚ùå Error installing hooks: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        return 1


def main():
    parser = argparse.ArgumentParser(
        description="Install git hooks for automatic Claude Code context capture"
    )
    parser.add_argument(
        "--force", "-f",
        action="store_true",
        help="Overwrite existing hooks without prompting"
    )

    args = parser.parse_args()
    sys.exit(install_hook(force=args.force))


if __name__ == "__main__":
    main()
