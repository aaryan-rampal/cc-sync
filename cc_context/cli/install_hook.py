#!/usr/bin/env python3
"""
cc-install-hook: Install git hooks for automatic context capture and sync

This command installs two git hooks:
1. post-commit: Automatically commits Claude sessions to parallel git repo
2. post-checkout: Syncs Claude sessions when checking out commits
"""

import sys
import subprocess
import argparse
from pathlib import Path


def install_hook(force: bool = False):
    """Install post-commit and post-checkout hooks to current repository"""
    try:
        from cc_context.utils.path import get_repo_root
        from cc_context.core.git_ops import is_claude_repo_initialized

        repo_root = get_repo_root()
        hooks_dir = repo_root / ".git" / "hooks"

        # Ensure hooks directory exists
        hooks_dir.mkdir(parents=True, exist_ok=True)

        # Check if Claude repo is initialized
        if not is_claude_repo_initialized():
            print()
            print("‚ö†Ô∏è  Warning: Claude sessions repo is not initialized!")
            print("   Run 'cc-init' first to enable automatic context capture.")
            print()
            if not force:
                try:
                    response = input("   Continue installing hooks anyway? [y/N] ").strip().lower()
                    if response != 'y':
                        print("   Aborted hook installation")
                        return 1
                except EOFError:
                    print("\n   Aborted hook installation")
                    return 1

        # Install post-commit hook (runs AFTER commit is created)
        post_commit_hook = hooks_dir / "post-commit"
        post_commit_content = """#!/bin/bash
# Claude Code Context Manager - Auto-commit sessions after commit
# Generated by cc-install-hook

cc-capture

# Don't fail if capture fails (commit already created)
exit 0
"""

        # Check if post-commit hook already exists
        if post_commit_hook.exists():
            if force:
                # Force flag: overwrite without asking
                backup_path = post_commit_hook.with_suffix(".backup")
                post_commit_hook.rename(backup_path)
                print(f"‚úì  Backed up existing hook to: {backup_path}")
                post_commit_hook.write_text(post_commit_content)
                post_commit_hook.chmod(0o755)
                print(f"‚úì  Installed post-commit hook")
            else:
                print(f"‚ö†Ô∏è  Post-commit hook already exists at: {post_commit_hook}")
                try:
                    response = input("   Overwrite existing post-commit hook? [y/N] ").strip().lower()
                    if response == 'y':
                        # Backup existing hook
                        backup_path = post_commit_hook.with_suffix(".backup")
                        post_commit_hook.rename(backup_path)
                        print(f"   Backed up existing hook to: {backup_path}")
                        post_commit_hook.write_text(post_commit_content)
                        post_commit_hook.chmod(0o755)
                        print(f"‚úì  Installed post-commit hook")
                    else:
                        print("   Skipped post-commit hook installation")
                        return 0
                except EOFError:
                    print("\n   Skipped post-commit hook installation (use --force to overwrite)")
                    return 0
        else:
            post_commit_hook.write_text(post_commit_content)
            post_commit_hook.chmod(0o755)
            print(f"‚úì  Installed post-commit hook at: {post_commit_hook}")

        # Install post-checkout hook
        post_checkout_hook = hooks_dir / "post-checkout"
        post_checkout_content = """#!/bin/bash
# Claude Code Context Manager - Sync sessions on checkout
# Generated by cc-install-hook

OLD_SHA=$1
NEW_SHA=$2
CHECKOUT_TYPE=$3

cc-checkout-sync "$OLD_SHA" "$NEW_SHA" "$CHECKOUT_TYPE"

exit 0
"""

        # Check if post-checkout hook already exists
        if post_checkout_hook.exists():
            if force:
                # Force flag: overwrite without asking
                backup_path = post_checkout_hook.with_suffix(".backup")
                post_checkout_hook.rename(backup_path)
                print(f"‚úì  Backed up existing hook to: {backup_path}")
                post_checkout_hook.write_text(post_checkout_content)
                post_checkout_hook.chmod(0o755)
                print(f"‚úì  Installed post-checkout hook")
            else:
                print(f"‚ö†Ô∏è  Post-checkout hook already exists at: {post_checkout_hook}")
                try:
                    response = input("   Overwrite existing post-checkout hook? [y/N] ").strip().lower()
                    if response == 'y':
                        # Backup existing hook
                        backup_path = post_checkout_hook.with_suffix(".backup")
                        post_checkout_hook.rename(backup_path)
                        print(f"   Backed up existing hook to: {backup_path}")
                        post_checkout_hook.write_text(post_checkout_content)
                        post_checkout_hook.chmod(0o755)
                        print(f"‚úì  Installed post-checkout hook")
                    else:
                        print("   Skipped post-checkout hook installation")
                except EOFError:
                    print("\n   Skipped post-checkout hook installation (use --force to overwrite)")
        else:
            post_checkout_hook.write_text(post_checkout_content)
            post_checkout_hook.chmod(0o755)
            print(f"‚úì  Installed post-checkout hook at: {post_checkout_hook}")

        print()
        print("=" * 60)
        print("üéâ Git hooks installed successfully!")
        print("=" * 60)
        print()
        print("The hooks will now automatically:")
        print("  ‚Ä¢ post-commit: Commit Claude sessions after every commit")
        print("  ‚Ä¢ post-checkout: Sync sessions when checking out commits")
        print()
        print("To test the setup:")
        print("  1. Make some changes and commit")
        print("  2. git checkout to different commits")
        print("  3. Sessions will automatically sync")
        print()
        print("To manually capture context:")
        print("  cc-capture")
        print()
        print("To uninstall hooks, delete:")
        print(f"  {post_commit_hook}")
        print(f"  {post_checkout_hook}")
        print()

        return 0

    except subprocess.CalledProcessError:
        print("‚ùå Error: Not in a git repository", file=sys.stderr)
        print("   Run this command from inside a git repository", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"‚ùå Error installing hooks: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        return 1


def main():
    parser = argparse.ArgumentParser(
        description="Install git hooks for automatic Claude Code context capture"
    )
    parser.add_argument(
        "--force", "-f",
        action="store_true",
        help="Overwrite existing hooks without prompting"
    )

    args = parser.parse_args()
    sys.exit(install_hook(force=args.force))


if __name__ == "__main__":
    main()
